# Transaction

하나의 작업을 수행하는데 필요한 데이터베이스 연산들을 모아놓은 것

작업 수행에 필요한 SQL 문들의 모임

- 특히, 데이터베이스를 변경하는 INSERT, DELETE, UPDATE 문의 실행을 관리

---

## 트랜잭션의 특성

### 원자성(atomicity)

    - 트랜잭션의 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 하는 all-or-nothing 방식을 의미

    - 만약 트랜잭션 수행 도중 장애가 발생하면?
        - 지금까지 실행한 연산 처리를 모두 취소하고, 데이터베이스를 트랜잭션 작업 전 상태로 되돌려야 함
    - 원자성의 보장을 위해 장애 발생 시 회복 기능이 필요

### 일관성(consistency)

    - 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 함을 의미

### 격리성, 고립성(isolation)

    - 수행 중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산 결과에 접근할 수 없음을 의미
    - 격리성의 보장을 위해서는 여러 트랜잭션이 동시에 수행되더라도 마치 순서대로 하나씩 수행되는 것처럼 정확하고 일관된 결과를 얻을 수 있도록 제어하는 기능이 필요

### 지속성(durability)

    - 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 영구적이어야 함을 의미
    - 지속성의 보장을 위해서는 장애 발생 시 회복 기능이 필요

## 트랜잭션 지원 DBMS 모듈

- 동시성 제어(concurrency control) 모듈
  - 대표적 동시성 제어 기법: 락킹(locking)
- 회복(recovery) 모듈
  - 대표적 회복 기법: 로깅(logging)

---

## 트랜잭션의 주요 연산

### commit 연산

    트랜잭션의 수행이 성공적으로 완료되었음을 선언하는 연산
    commit 연산이 실행되면 트랜잭션의 수행 결과가 데이터베이스에 반영되고 일관된 상태를 지속적으로 유지하게 됨

### rollback 연산

    트랜잭션의 수행이 실패했음을 선언하는 연산
    rollback 연산이 실행되면 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 데이터베이스가 트랜잭션 수행 전의 일관된 상태로 되돌아감

---

## 트랜잭션의 상태

### 활동(active) 상태

    트랜잭션이 수행되기 시작하여 현재 수행 중인 상태

### 부분 완료(partially committed) 상태

    트랜잭션의 마지막 연산이 실행을 끝낸 직후의 상태

### 완료(committed) 상태

    - 트랜잭션이 성공적으로 완료되어 commit 연산을 실행한 상태
    - 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하고, 데이터베이스가 새로운 일관된 상태가 되면서 트랜잭션이 종료됨

### 실패(failed) 상태

    장애가 발생하여 트랜잭션의 수행이 중단된 상태

### 철회(aborted) 상태

    - 트랜잭션의 수행 실패로 rollback 연산을 실행한 상태
    - 지금까지 실행한 트랜잭션의 연산을 모두 취소하고 트랜잭션이 수행되기 전의 데이터베이스 상태로 되돌리면서 트랜잭션이 종료됨
    - 철회 상태로 종료된 트랜잭션은 상황에 따라 다시 수행되거나 폐기됨

---

## 트랜잭션의 종류

### 명시적 트랜잭션

    - 트랜잭션의 시작과 끝을 사용자가 직접 명시적으로 지정하는 트랜잭션
    - ‘사용자 트랜잭션’ 또는 ‘수동 트랜잭션’

    설정
    - START TRANSACTION 명령문은 직접 트랜잭션의 시작을 지시
    - COMMIT 명령문은 트랜잭션의 모든 처리 결과의 정상적 처리를 확정하는 명령어로 변경 내용을 모두 실제 데이터베이스에 영구적으로 반영함
    - ROLLBACK 명령문은 작업 중 장애나 문제가 발생하여 트랜잭션의 처리 과정에서 발생한 변경 내용을 모두 취소하는 명령어로 트랜잭션 시작 이전의 원래 상태로 되돌림

### 자동완료 트랜잭션

    - SQL문 하나를 독립된 하나의 트랜잭션으로 자동 정의하고 SQL문의 실행 결과에 따라 자동으로 커밋 또는 롤백하는 트랜잭션
    - 기본 모드의 트랜잭션, ‘시스템 트랜잭션’

    설정
    - ‘@@AUTOCOMMIT’은 트랜잭션 모드 설정 값을 저장하고 있는 시스템 변수
    - 값이 ‘1’이면 자동완료 모드가 설정된 것

### 수동완료 트랜잭션

    - 트랜잭션의 끝만 사용자가 직접 명시적으로 지정하는 트랜잭션
    - ‘암시적(implicit) 트랜잭션’
    - 다음 명령문 실행하면 START TRANSACTION 명령문 없이도 트랜잭션이 자동으로 시작

    설정
    - 다음과 같이 수동완료 모드를 설정하면 START TRANSACTION 명령문은 필요 없으나 COMMIT 명령문이나 ROLLBACK 명령문은 반드시 명세해야 함

---

# 장애와 회복

## 장애(failure)

    시스템이 제대로 동작하지 않는 상태

### 트랜잭션의 수행을 위해 필요한 데이터 이동연산

    - 디스크와 메인 메인 메모리 간의 데이터 이동 연산 : input / output
    블록(block) 단위로 수행됨
        • 디스크 블록 : 디스크에 있는 블록
        • 버퍼 블록 : 메인 메모리에 있는 블록

    - 메인 메모리와 프로그램 변수 간의 데이터 이동 연산 : read / write

    응용 프로그램에서 트랜잭션의 수행을 지시하면 메인 메모리 버퍼 블록에 있는 데이터를 프로그램의 변수로 가져오고, 데이터 처리 결과를 저장한 변수 값을 메인 메모리 버퍼 블록으로 옮기는 작업이 필요

### 디스크와 메인 메모리 간 데이터 이동 연산의 필요성

    - 일반적으로 데이터베이스는 비휘발성 저장 장치인 디스크에 상주

    - 트랜잭션이 데이터베이스의 데이터를 처리하기 위해서는 데이터를 디스크에서 메인 메모리로 가져와 처리한 다음 그 결과를 디스크로 보내는 작업이 필요함

## 회복(recovery)

    - 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구시키는 것

    - 트랜잭션의 특성을 보장하고, 데이터베이스를 일관된 상태로 유지하기 위해 필수적인 기능

    - 회복 관리자(recovery manager)가 담당

### 회복을 위한 기본 연산

    - redo(재실행)
    - undo(취소)

로그 파일 : 데이터를 변경하기 이전의 값과 변경한 이후의 값을 기록한 파일

---

## 로그 회복 기법

### 즉시 갱신(immediate update) 회복 기법

    - 트랜잭션 수행 중에 데이터 변경 연산의 결과를 데이터베이스에 즉시 반영

    - 장애 발생에 대비하기 위해 데이터 변경에 대한 내용을 로그 파일에 기록

    - 데이터 변경 연산이 실행되면, 로그 파일에 로그 레코드를 먼저 기록한 다음 데이터베이스에 변경 연산을 반영

    - 장애 발생 시점에 따라 redo나 undo 연산을 실행해 데이터베이스를 복구

### 지연 갱신(deferred update) 회복 기법

    - 트랜잭션 수행 중에 데이터 변경 연산의 결과를 로그에만 기록해두고, 트랜잭션이 부분 완료된 후에 로그에 기록된 내용을 이용해 데이터베이스에 한번에 반영

    - 트랜잭션 수행 중에 장애가 발생할 경우 로그에 기록된 내용을 버리기만 하면 데이터베이스가 원래 상태를 그대로 유지하게 됨

    - undo 연산은 필요없고 redo 연산만 사용

### 검사 시점 회복 기법

    - 로그 기록을 이용하되, 일정 시간 간격으로 검사 시점(checkpoint)을 만듦

    - 로그 전체를 대상으로 회복 기법을 적용할 때 발생할 수 있는 비효율성의 문제를 해결

### 미디어 회복 기법

    - 디스크에 발생할 수 있는 장애에 대비한 회복 기법

    - 덤프(복사본) 이용: 전체 데이터베이스의 내용을 일정 주기마다 다른 안전한 저장 장치에 복사

    - 가장 최근에 복사해둔 덤프를 이용해 장애 발생 이전의 데이터베이스 상태로 복구하고 필요에 따라 redo 연산을 수행

---

# 병행 수행

## 병행 수행

    여러 사용자가 데이터베이스를 동시 공유할 수 있도록 여러 개의 트랜잭션을 동시에 수행하는 것을 의미

## 병행 제어(concurrency control) 또는 동시성 제어

    병행 수행 시 같은 데이터에 접근하여 연산을 실행해도 문제가 발생하지 않고 정확한 수행 결과를 얻을 수 있도록 트랜잭션의 수행을 제어하는 것을 의미

---

## 병행 수행 시 발생할 수 있는 문제점

### - 갱신 분실(lost update)

    하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화되는 것

### - 모순성(inconsistency)

    하나의 트랜잭션이 여러 개 데이터 변경 연산을 실행할 때 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산함으로써 모순된 결과가 발생하는 것

### - 연쇄 복귀(cascading rollback)

    트랜잭션이 완료되기 전 장애가 발생하여 rollback 연산을 수행하면, 장애 발생 전에 이 트랜잭션이 변경한 데이터를 가져가서 변경 연산을 실행한 다른 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 한다는 것

---

## 트랜잭션 스케줄

### 직렬 스케줄(serial schedule)

- 의미
  - 인터리빙 방식을 이용하지 않고 각 트랜잭션별로 연산들을 순차적으로 실행시키는 것
- 특징
  - 직렬 스케줄에 따라 트랜잭션이 수행되면, 다른 트랜잭션의 방해를 받지 않고 독립적으로 수행되므로 항상 모순이 없는 정확한 결과를 얻게 됨
  - 다양한 직렬 스케줄이 만들어질 수 있고, 직렬 스케줄마다 데이터베이스에 반영되는 최종 결과가 다를 수 있지만 직렬 스케줄의 결과는 모두 정확함
  - 각 트랜잭션을 독립적으로 수행하기 때문에 병행 수행으로 볼 수 없음

### 비직렬 스케줄(nonserial schedule)

- 의미
  - 인터리빙 방식을 이용하여 트랜잭션을 병행 수행하는 것
- 특징
  - 트랜잭션이 번갈아 연산을 실행하기 때문에 하나의 트랜잭션이 완료되기 전에 다른 트랜잭션의 연산이 실행될 수 있음
  - 비직렬 스케줄에 따라 병행 수행하면 갱신 분실, 모순성, 연쇄 복귀 등의 문제가 발생할 수 있어 결과의 정확성을 보장할 수 없음
  - 다양한 비직렬 스케줄이 만들어질 수 있고 그 중에는 잘못된 결과를 생성하는 것도 있음

### 직렬 가능 스케줄(serializable schedule)

- 의미

  - 직렬 스케줄에 따라 수행한 것과 같이 정확한 결과를 생성하는 비직렬 스케줄
  - 비직렬 스케줄 중에서 수행 결과가 동일한 직렬 스케줄이 있는 것

- 특징
  - 인터리빙 방식으로 병행 수행하면서도 정확한 결과를 얻을 수 있음
  - 직렬 가능 스케줄인지 판단하는 것은 간단한 작업이 아니므로 직렬 가능성을 보장하는 병행 제어 기법을 사용하는 것이 일반적임

---

## 병행 제어 기법

- 병행 수행하면서도 직렬 가능성을 보장하기 위한 기법

- 대표적인 병행 제어 기법: 로킹 기법

## 로킹(locking) 기법

### 기본 원리

    - 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 끝낼 때까지는 다른 트랜잭션이 그 데이터에 접근하지 못하도록 상호 배제(mutual exclusion)함

    - 바람직한 동시성(concurrency)이란 2개 이상의 트랜잭션을 동시에 실행하는 비직렬 스케쥴(non-serial schedule)의 결과가 트랜잭션을 뒤섞지 않고 순차적으로 실행하는 직렬 스케쥴(serial schedule)의 결과와 같도록 보장하는 것
    -> 직렬 가능 스케줄(serializable schedule)

    - 직렬 가능성(serializability)을 보장하기 위한 방법 중 하나가 lock을 이용하는 것

### 방법

    병행 수행되는 트랜잭션들이 같은 데이터에 동시에 접근하지 못하도록 lock과 unlock 연산을 이용해 제어
        • lock : 트랜잭션이 데이터에 대한 독점권을 요청하는 연산
        • unlock : 트랜잭션이 데이터에 대한 독점권을 반환하는 연산

### 기본 로킹 규약

    - 트랜잭션은 데이터에 접근하기 위해 먼저 lock 연산을 실행해 독점권을 획득함(read, write 연산 전에 lock 연산을 실행)

    - 다른 트랜잭션에 의해 이미 lock 연산이 실행된 데이터에는 다시 lock 연산을 실행할 수 없음

    - 독점권을 획득한 데이터에 대한 모든 연산의 수행이 끝나면 트랜잭션은 unlock 연산을 실행해서 독점권을 반납해야 함

### 로킹 단위

    -  lock 연산을 실행하는 대상 데이터의 크기

    - 전체 데이터베이스부터 릴레이션, 투플, 속성까지도 가능함

    - 로킹 단위가 커질수록 병행성은 낮아지지만 제어가 쉬움
